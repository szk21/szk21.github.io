---
layout: post
title:  "C#中的委托和事件"
date:   2017-08-08 17:14:54
categories: 编程
excerpt: 
---

* content
{:toc}

## 引言

委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。

## 将方法作为方法的参数

我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：

	public void GreetPeople(string name) {
		// 做某些额外的事情，比如初始化之类，此处略
		EnglishGreeting(name);
	}
	public void EnglishGreeting(string name) {
		Console.WriteLine("Morning, " + name);
	}

暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。

现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：

	public void ChineseGreeting(string name){
		Console.WriteLine("早上好, " + name);
	}
	
这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：

	public enum Language{
		English, Chinese
	}

	public void GreetPeople(string name, Language lang){
		//做某些额外的事情，比如初始化之类，此处略
		swith(lang){
			case Language.English:
			   EnglishGreeting(name);
			   break;
		   case Language.Chinese:
			   ChineseGreeting(name);
			   break;
		}
	}
	
OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。

在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：

	public void GreetPeople(string name, Language lang)
	
我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。

如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：

	MakeGreeting(name);
	
好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：

	public void GreetPeople(string name, *** MakeGreeting){
    MakeGreeting(name);
	}
	
注意到\*\*\*，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：**这个代表着方法的MakeGreeting参数应该是什么类型的？**

**NOTE：**这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。

聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的ChineseGreeting()和EnglishGreeting()方法的签名：

	public void EnglishGreeting(string name)
	public void ChineseGreeting(string name)
	
如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。**MakeGreeting的参数类型定义应该能够确定MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。**

于是，委托出现了：**它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。**

**NOTE：**如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。

本例中委托的定义：

	public delegate void GreetingDelegate(string name);
	
可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？

现在，让我们再次改动GreetPeople()方法，如下所示：

	public void GreetPeople(string name, GreetingDelegate MakeGreeting){
		MakeGreeting(name);
	}
	
如你所见，委托GreetingDelegate出现的位置与string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：

	using System;
	using System.Collections.Generic;
	using System.Text;

	namespace Delegate {
		 //定义委托，它定义了可以代表的方法的类型
		 public delegate void GreetingDelegate(string name);
			class Program {

			   private static void EnglishGreeting(string name) {
				   Console.WriteLine("Morning, " + name);
			   }

			   private static void ChineseGreeting(string name) {
				   Console.WriteLine("早上好, " + name);
			   }

			   //注意此方法，它接受一个GreetingDelegate类型的方法作为参数
			   private static void GreetPeople(string name, GreetingDelegate MakeGreeting) {
				   MakeGreeting(name);
				}

			   static void Main(string[] args) {
				   GreetPeople("Jimmy Zhang", EnglishGreeting);
				   GreetPeople("张子阳", ChineseGreeting);
				   Console.ReadKey();
			   }
			}
		}

输出如下：
Morning, Jimmy Zhang
早上好, 张子阳

我们现在对委托做一个总结：

**委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。**